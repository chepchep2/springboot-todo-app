# Spring Boot Todo App 코드 리뷰

**리뷰 일자**: 2025-12-04
**프로젝트**: JWT 기반 인증과 Todo CRUD를 제공하는 REST API 서버

---

## 1. 개요

전체적으로 **잘 구조화된 프로젝트**이며, 레이어드 아키텍처(Controller → Service → Domain → Repository)를 잘 따르고 있습니다.

---

## 2. 좋은 점 (Strengths)

### 2.1 아키텍처 및 구조
- **명확한 레이어 분리**: Controller → Service → Domain → Repository
- **도메인 모델 중심 설계**: Entity에 비즈니스 로직 포함 (`toggleComplete()`, `changeAssignees()` 등)
- **Builder 패턴 직접 구현**: Lombok 의존성 없이 수동 구현하여 학습/이해에 좋음

### 2.2 보안
- **JWT 기반 Stateless 인증**: Session 없이 토큰 기반 인증
- **BCrypt 비밀번호 암호화**: 안전한 패스워드 해싱
- **소유권 검증**: `findByIdAndUserId()`로 다른 사용자의 Todo 접근 차단

### 2.3 기능 설계
- **Soft Delete 구현**: `@Where(clause = "deleted_at IS NULL")`로 자동 필터링
- **Swagger 문서화**: OpenAPI 어노테이션으로 API 문서 자동 생성
- **Assignee 관계 설계**: N:M 관계를 중간 테이블로 적절히 처리

### 2.4 코드 품질
- **Record 활용**: DTO에 Java Record 사용으로 불변성 보장
- **생성자 주입**: 필드 주입 대신 생성자 주입 사용
- **트랜잭션 관리**: 적절한 `@Transactional` 사용

---

## 3. 개선이 필요한 점 (Critical Issues)

### 3.1 HTTP Status 코드 오류

**파일**: `src/main/java/com/chep/demo/todo/exception/todo/TodoNotFoundException.java:6`

```java
@ResponseStatus(HttpStatus.UNAUTHORIZED)  // 401
public class TodoNotFoundException extends RuntimeException {
```

| 현재 | 문제점 | 권장 |
|-----|-------|-----|
| 401 Unauthorized | Todo 미존재 시 401 반환하여 클라이언트가 인증 실패로 오인함 | **404 Not Found** |

**수정 방안**:
```java
@ResponseStatus(HttpStatus.NOT_FOUND)  // 404
public class TodoNotFoundException extends RuntimeException {
```

---

### 3.2 JWT 토큰 타입 구분 없음 (보안 취약점)

**파일**:
- `src/main/java/com/chep/demo/todo/service/auth/AuthService.java:72-88`
- `src/main/java/com/chep/demo/todo/security/JwtTokenProvider.java`

**문제점**:
- JWT에 토큰 타입(access/refresh) 클레임이 없음
- `/api/auth/refresh`에 만료 전 access token을 넣어도 새 access token이 발급됨
- access token의 만료 시간 의미가 사라짐

**현재 코드**:
```java
// AuthService.java:72-88
public AuthResult refresh(String refreshToken) {
    if (!jwtTokenProvider.validateToken(refreshToken)) {  // 타입 검증 없음
        throw new AuthenticationException("Invalid refresh token");
    }
    Long userId = jwtTokenProvider.getUserIdFromToken(refreshToken);
    // ...
}
```

**수정 방안**:
```java
// JwtTokenProvider.java - 토큰 생성 시 타입 클레임 추가
public String generateAccessToken(Long userId) {
    return Jwts.builder()
            .setSubject(userId.toString())
            .claim("type", "access")  // 타입 추가
            .setIssuedAt(now)
            .setExpiration(expiryDate)
            .signWith(key, SignatureAlgorithm.HS256)
            .compact();
}

public String generateRefreshToken(Long userId) {
    return Jwts.builder()
            .setSubject(userId.toString())
            .claim("type", "refresh")  // 타입 추가
            // ...
}

// 토큰 타입 검증 메서드 추가
public boolean isRefreshToken(String token) {
    Claims claims = parseClaims(token);
    return "refresh".equals(claims.get("type"));
}
```

```java
// AuthService.java - refresh 시 토큰 타입 검증
public AuthResult refresh(String refreshToken) {
    if (!jwtTokenProvider.validateToken(refreshToken)) {
        throw new AuthenticationException("Invalid refresh token");
    }
    if (!jwtTokenProvider.isRefreshToken(refreshToken)) {
        throw new AuthenticationException("Not a refresh token");
    }
    // ...
}
```

---

### 3.3 순서(orderIndex) 관리 무결성 허점

**파일**: `src/main/java/com/chep/demo/todo/service/todo/TodoService.java:31-135`

#### 문제점 1: 생성 시 orderIndex 지정해도 기존 항목 재배치 없음

```java
// TodoService.java:39-60
public Todo createTodo(Long userId, CreateTodoRequest request) {
    Integer orderIndex = request.orderIndex();
    if (orderIndex == null) {
        orderIndex = todoRepository.countByUserId(userId).intValue();
    }
    // orderIndex가 지정되어도 기존 항목 재배치 없음 → 중복/충돌 발생 가능
    Todo todo = Todo.builder()
            .orderIndex(orderIndex)
            // ...
}
```

#### 문제점 2: 이동 시 인덱스 범위 검증 없음

```java
// TodoService.java:98-137
public void move(Long userId, Long todoId, MoveTodoRequest request) {
    Integer targetOrderIndex = request.targetOrderIndex();
    // 음수나 최대값 초과 검증 없음 → 500 에러 또는 갭/중복 발생
    // ...
}
```

**수정 방안**:
```java
public Todo createTodo(Long userId, CreateTodoRequest request) {
    Integer orderIndex = request.orderIndex();
    Long totalCount = todoRepository.countByUserId(userId);

    if (orderIndex == null) {
        orderIndex = totalCount.intValue();
    } else {
        // 범위 검증
        if (orderIndex < 0 || orderIndex > totalCount) {
            throw new IllegalArgumentException("orderIndex out of range: 0 ~ " + totalCount);
        }
        // 기존 항목 재배치
        List<Todo> affectedTodos = todoRepository.findByUserIdAndOrderIndexGreaterThanEqual(userId, orderIndex);
        for (Todo affected : affectedTodos) {
            affected.changeOrderIndex(affected.getOrderIndex() + 1);
        }
        todoRepository.saveAll(affectedTodos);
    }
    // ...
}

public void move(Long userId, Long todoId, MoveTodoRequest request) {
    Integer targetOrderIndex = request.targetOrderIndex();
    Long totalCount = todoRepository.countByUserId(userId);

    // 범위 검증
    if (targetOrderIndex < 0 || targetOrderIndex >= totalCount) {
        throw new IllegalArgumentException("targetOrderIndex out of range: 0 ~ " + (totalCount - 1));
    }
    // ...
}
```

---

### 3.4 요청 검증이 도메인 규칙보다 약함 (500 에러 노출)

**파일**:
- `src/main/java/com/chep/demo/todo/dto/todo/CreateTodoRequest.java:8-15`
- `src/main/java/com/chep/demo/todo/dto/todo/UpdateTodoRequest.java:4-9`
- `src/main/java/com/chep/demo/todo/domain/todo/Todo.java:58-69`

#### 문제점: DTO에서 content가 null 가능하지만 Entity는 불가

**DTO (검증 없음)**:
```java
// CreateTodoRequest.java
public record CreateTodoRequest(
        @NotEmpty(message = "Title is required")
        String title,
        String content,  // @NotEmpty 없음 - null 가능
        Integer orderIndex,
        Instant dueDate,
        List<Long> assigneeIds
) {}
```

**Entity (null 불가)**:
```java
// Todo.java:58-69
private Todo(User user, String title, String content, Integer orderIndex, Instant dueDate) {
    if (content == null) {
        throw new IllegalArgumentException("content must not be null");  // 500 에러
    }
    // ...
}
```

#### 문제점: IllegalArgumentException이 500으로 노출됨

- 잘못된 assignee ID → `IllegalArgumentException` → 500
- 잘못된 orderIndex → `IllegalArgumentException` → 500

**수정 방안 1 - DTO Validation 강화**:
```java
// CreateTodoRequest.java
public record CreateTodoRequest(
        @NotEmpty(message = "Title is required")
        String title,
        @NotNull(message = "Content is required")
        String content,
        @Min(value = 0, message = "orderIndex must be >= 0")
        Integer orderIndex,
        Instant dueDate,
        List<Long> assigneeIds
) {}
```

**수정 방안 2 - GlobalExceptionHandler 추가**:
```java
@ControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(IllegalArgumentException.class)
    public ResponseEntity<ErrorResponse> handleIllegalArgument(IllegalArgumentException e) {
        return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                .body(new ErrorResponse(e.getMessage()));
    }

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorResponse> handleValidation(MethodArgumentNotValidException e) {
        String message = e.getBindingResult().getFieldErrors().stream()
                .map(error -> error.getField() + ": " + error.getDefaultMessage())
                .collect(Collectors.joining(", "));
        return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                .body(new ErrorResponse(message));
    }
}

public record ErrorResponse(String message) {}
```

---

### 3.5 테스트 부재

**파일**: `src/test/java/com/chep/demo/todo/ApplicationTests.java:7-13`

**현재 상태**:
```java
@SpringBootTest
class ApplicationTests {
    @Test
    void contextLoads() {
    }
}
```

**문제점**:
- 컨텍스트 로드 테스트 외에 없음
- 인증/할일 흐름 검증 없음
- 정렬 로직 검증 없음
- JWT 필터 검증 없음

**필요한 테스트**:

| 테스트 종류 | 대상 | 검증 항목 |
|-----------|-----|---------|
| 단위 테스트 | `JwtTokenProvider` | 토큰 생성, 검증, 만료 처리 |
| 단위 테스트 | `TodoService` | CRUD, orderIndex 재배치 로직 |
| 단위 테스트 | `AuthService` | 회원가입, 로그인, 토큰 갱신 |
| 통합 테스트 | `AuthController` | 인증 플로우 전체 |
| 통합 테스트 | `TodoController` | Todo CRUD API |
| 통합 테스트 | `JwtAuthenticationFilter` | 필터 동작 검증 |

---

## 4. 기타 개선 사항

### 4.1 보안 설정 (환경변수 분리 필요)

**파일**: `src/main/resources/application.properties`

```properties
# 현재 - 하드코딩됨
jwt.secret=dGhpcy1pcy1hLXZlcnktc2VjcmV0LWtleS1jaGFuZ2UtaXQtMTIzNDU2Nzg5MA==
spring.datasource.password=postgres
```

**권장**:
```properties
jwt.secret=${JWT_SECRET}
spring.datasource.password=${DB_PASSWORD}
```

### 4.2 Refresh Token 저장소 부재

- **현재**: Refresh Token이 DB에 저장되지 않음
- **위험**: 탈취된 토큰을 무효화할 방법 없음
- **권장**: Redis 또는 DB에 Refresh Token 저장 후 검증

### 4.3 코드 오타

| 파일 | 라인 | 현재 | 수정 |
|-----|-----|-----|-----|
| `Todo.java` | 72 | `"orderIndex must not bee null"` | `"be"` |
| `Todo.java` | 76 | `this.title =title;` | `this.title = title;` |
| `TodoAssignee.java` | 46 | `this.user =user;` | `this.user = user;` |

---

## 5. 요약 테이블

| 카테고리 | 상태 | 설명 |
|---------|------|-----|
| 아키텍처 | :white_check_mark: | 레이어드 아키텍처 잘 적용됨 |
| 보안 | :warning: | JWT Secret 하드코딩, 토큰 타입 미구분, Refresh Token 관리 미흡 |
| Validation | :warning: | 일부 필드 검증 누락, 500 에러 노출 |
| 에러 처리 | :warning: | 글로벌 핸들러 없음, HTTP 상태 코드 오류 |
| 순서 관리 | :warning: | orderIndex 무결성 허점 |
| 테스트 | :x: | 테스트 코드 거의 없음 |
| 문서화 | :white_check_mark: | Swagger 적용됨 |
| 코드 품질 | :white_check_mark: | 전반적으로 깔끔함 (minor 오타 존재) |

---

## 6. 우선순위별 개선 권장사항

### 높음 (즉시 수정 필요)
1. `TodoNotFoundException` HTTP 상태 코드 404로 수정
2. JWT 토큰에 타입 클레임 추가 (access/refresh 구분)
3. GlobalExceptionHandler 추가하여 IllegalArgumentException → 400 매핑
4. DTO Validation 강화 (content, orderIndex 등)

### 중간 (보안/안정성)
5. JWT Secret 환경변수 분리
6. orderIndex 생성/이동 시 범위 검증 및 재배치 로직 보완
7. Refresh Token 저장소 구현
8. 테스트 코드 작성

### 낮음 (코드 품질)
9. 오타 수정
10. 동시성 처리 (Pessimistic/Optimistic Lock)

---

## 7. 결론

전체적으로 학습/사이드 프로젝트로 **잘 구현된 코드**입니다.
프로덕션 배포 전 **높음** 우선순위 항목들을 먼저 해결하고,
**중간** 우선순위 보안 관련 사항들을 처리하면 안정적인 서비스가 될 것입니다.
